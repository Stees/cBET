#! /usr/bin/env python
#code will determine the greatest interaction energy for each molecule calculation pair, and provide a convenient view of final and initial positions for the optimization

import subprocess
import readline
import shutil
from re import sub
from collections import defaultdict
from decimal import *
import numpy as np
import time

#set decimal context
getcontext().prec = 14

getHost = subprocess.Popen('hostname', stdout=subprocess.PIPE)
host = getHost.communicate()[0].split()[0]

if 'login0a.mpi.sam.pitt.edu' in host:
    trajectoryLocation = '/ihome/kjohnson/jpr54/cp2k/bestInteractionTrajectories/'

    #figure out what is in the queue
    currentJobs = subprocess.Popen("squeue -u $USER -o '%7i%24j%8u' | grep 'jpr54' | awk '{print $1;}'", stdout=subprocess.PIPE, shell=True)
    activeJobs = currentJobs.communicate()[0].split()
    #print('{0}'.format(activeJobs))
    #identify all the energies of the single molecules
    sStructures = subprocess.Popen('ls', stdout=subprocess.PIPE, cwd='/ihome/kjohnson/jpr54/cp2k/singleMolecules/')
    singleMolecules1 = sStructures.communicate()[0].split()
    d = defaultdict(list)

    #create array to hold energies of single molecules.
    #get the energies of all the single molecules, store them in the dictionary in position corresponding to name
    for counter, structure in enumerate(singleMolecules1):
        if structure.lower() not in d.keys():
            k = structure.lower()
            if structure in singleMolecules1:
                location = '/ihome/kjohnson/jpr54/cp2k/singleMolecules/' + structure + '/'
                files = subprocess.Popen('ls', stdout=subprocess.PIPE, cwd=location)
                fileNames = files.communicate()[0].split()
                #next line will only show calculations that have started running
                if "geometryOptimization.out" in fileNames:
                    calcSuccess = subprocess.Popen('grep "GEOMETRY OPTIMIZATION COMPLETED" geometryOptimization.out', stdout=subprocess.PIPE, cwd=location, shell=True)
                    scfSuccess = subprocess.Popen('grep "WARNING in qs_scf.F" geometryOptimization.out', stdout=subprocess.PIPE, cwd=location, shell=True)
                    calcFlag = calcSuccess.communicate()[0]
                    scfFlag = scfSuccess.communicate()[0]

                #make sure the success message is present in the file
                if "OPTIMIZATION" in str(calcFlag):
                    getEnergy = subprocess.Popen('grep "ENERGY| Total FORCE_EVAL" geometryOptimization.out | tail -n 1', stdout=subprocess.PIPE, cwd=location, shell=True)
                    v = Decimal(getEnergy.communicate()[0].split()[8])
                    d[k].append(v)
                elif "WARNING" in str(scfFlag):
                    print('scf run did not converge in {0}\m'.format(location))
                else:
                    getNumber = subprocess.Popen("bash -O extglob -c 'ls !(*.*)'", stdout=subprocess.PIPE, cwd=location, shell=True)
                    tempNumber = getNumber.communicate()[0]
                    if tempNumber not in activeJobs:
                        print('\n\n\n*****Walltime likely exceeded*****\n{0}\n\n\n'.format(location))


    #get the names of the interaction configurations
    iStructures = subprocess.Popen(r'ls *_* -d', stdout=subprocess.PIPE, cwd='/ihome/kjohnson/jpr54/cp2k/interactions/', shell=True)
    interactions1 = iStructures.communicate()[0].split()


    #make another dictionary for the interaction calculation energies
    d2 = defaultdict(list)
    d3 = defaultdict(list)
    #get the most negative energy for each interaction, and every energy for the interaction 
    for iStruct in (interactions1):
        if iStruct.lower() not in d2.keys():
            tempListAllEnergies = []
            tempListAllConfigs = []
            k = iStruct
            if iStruct in interactions1:
                outerLocation = '/ihome/kjohnson/jpr54/cp2k/interactions/' + iStruct + '/'
                #ls the number directories for each interaction pair
                nums = subprocess.Popen(r'ls -d */', stdout=subprocess.PIPE, cwd=outerLocation, shell=True)
                numbers = nums.communicate()[0].split()
                #find the mimimum for each calculation
                minimum = 0
                index = 0
                for number in numbers:
                    innerLocation = outerLocation + str(number)
                    files2 = subprocess.Popen('ls', stdout=subprocess.PIPE, cwd=innerLocation)
                    fileNames2 = files2.communicate()[0].split()
                    if "geometryOptimization.out" in fileNames2:
                        calcSuccess2 = subprocess.Popen('grep "GEOMETRY OPTIMIZATION COMPLETED" geometryOptimization.out', stdout=subprocess.PIPE, cwd=innerLocation, shell=True)
                        calcFlag2 = calcSuccess2.communicate()[0]
                        if "OPTIMIZATION" in str(calcFlag2):
                            getEnergy = subprocess.Popen('grep "ENERGY| Total FORCE_EVAL" geometryOptimization.out | tail -n 1', stdout=subprocess.PIPE, cwd=innerLocation, shell=True)
                            v = Decimal(getEnergy.communicate()[0].split()[8])
                            tempListAllEnergies.append(v)
                            tempListAllConfigs.append(number)
                            trajectoryMoveLocation = trajectoryLocation+iStruct+'OptimumTrajectory.xyz'
                            if v < minimum:
                                minimum = v
                                index = number
                                copyTrajectory = subprocess.Popen('cp -f *-pos-1.xyz {0}'.format(trajectoryMoveLocation), stdout=subprocess.PIPE, cwd=innerLocation, shell=True)
                        else:
                            getNumber = subprocess.Popen("bash -O extglob -c 'ls !(*.*)'", stdout=subprocess.PIPE, cwd=innerLocation, shell=True)
                            tempNumber = getNumber.communicate()[0].split()[0]
                            #print('{0}'.format(tempNumber))

                            if tempNumber not in activeJobs:
                                print('\n\n\n*****Walltime likely exceeded*****\n{0}\n'.format(innerLocation))
                                print('Restarting...\n')
                                #open the jobscript, replace the name of the input file with the name of the restart file
                                jobfile = open(innerLocation+'job.slurm','r')
                                modLines = jobfile.readlines()
                                jobfile.close()
                                newJobFile = open(innerLocation+'newJob.slurm','w')
                                for line in modLines:
                                    if "mpirun -np $SLURM_NTASKS $(which cp2k.popt) -i geometryOptimization" in line:
                                        newJobFile.write('mpirun -np $SLURM_NTASKS $(which cp2k.popt) -i {0}-1.restart -o geometryOptimization.out\n'.format(iStruct+'_'+number.split('/',1)[0]))
                                    else:
                                        newJobFile.write(line)
                                newJobFile.close()
                                changeName = subprocess.Popen('mv newJob.slurm job.slurm', cwd=innerLocation, shell=True)
                                #start the job
                                subprocess.Popen("bash -O extglob -c 'ls !(*.*) | xargs rm'", cwd=innerLocation, shell=True)
                                startJob = subprocess.Popen('sbatch job.slurm', stdout=subprocess.PIPE, cwd=innerLocation, shell=True)
                                jobNumber = startJob.communicate()[0].split()[3]
                                print('{0} {1}'.format(jobNumber,iStruct+'_'+number))
                                #remove old job number from directory, write the new one
                                subprocess.Popen("bash -O extglob -c 'touch {0}'".format(jobNumber), cwd=innerLocation, shell=True)

            d2[k].append(minimum)
            d2[k].append(index)
            d3[k].append(tempListAllEnergies)
            d3[k].append(tempListAllConfigs)

#*******************Part 3: data output
#calculate the interaction energies
    #allow for selection of only specific analyte to print
    filter = 5
    switchType = 1
    while (switchType != 0):
        while (filter != 1 and filter != 2 and filter != 3 and filter != 4):
            if (filter != 5):
                print('\nLikely invalid entry. Try again.\n\n')
            f1 = raw_input('\n\nTo print energies for all pairs, type 1.\nTo filter data, type 2.\nTo print all interaction energies for a single pair, type 3.\nTo exit, type 4\n\n')
            if not f1:
                print('\nEnter a value\n')
                filter = 5
            else:
                try:
                    filter = int(f1)
                except ValueError:
                    print('\nInvalid entry. Try again.\n')
            if (filter == 1):
                #for each key in d2, split the key at the underscore.
                for key in d2:
                    singleMols = key.split("_")
                    energy1 = d.get(singleMols[0].lower())
                    energy2 = d.get(singleMols[1].lower())
                    interE = d2.get(key)
                    print('\n{0}, configuration {1}'.format(singleMols,interE[1].replace("/","")))
                    #2625.5 is conversion factor between hartree and kJ/mol
                    bindingEnergy = Decimal(str(2625.5))*(interE[0] - (energy1[0] + energy2[0]))
                    print('{0} kJ/mol'.format(bindingEnergy))
            elif (filter == 2):
                agent = 'apple'
                flag = 0
                while (agent != 'owl'):
                    if (agent != 'apple'):
                        if (agent == 'more'):
                            print('\nJust one second...\n')
                            time.sleep(0.55)
                        else:
                            print('\nLikely invalid entry. Try again.\n\n')
                    agent = raw_input('Enter the name of an agent.\n')
                    for key in d2:
                        if agent in key:
                            flag = 1
                            singleMols = key.split("_")
                            energy1 = d.get(singleMols[0].lower())
                            energy2 = d.get(singleMols[1].lower())
                            interE = d2.get(key)
                            print('\n{0}, configuration {1}'.format(singleMols,interE[1].replace("/","")))
                            #2625.5 is conversion factor between hartree and kJ/mol
                            bindingEnergy = Decimal('2625.5')*(interE[0] - (energy1[0] + energy2[0]))
                            print('{0} kJ/mol'.format(bindingEnergy))
                    if (flag == 1):
                        repeat = 's'
                        while (repeat != 'y' and repeat != 'n'):
                            if (repeat != 's'):
                                print('\nInvalid entry. Try again.\n')
                            repeat = raw_input('\nAdditional data needed? (y/n)\n')
                            if not repeat:
                                print('\nEnter a value\n')
                                repeat = 's'
                            if (repeat == 'y'):
                                agent = 'more'
                            elif (repeat == 'n'):
                                agent = 'owl'
            elif (filter == 3):
                #print all binding energies for a specified molecule
                agent = 'apple'
                flag = 0
                while (agent != 'owl'):
                    pairArray = []
                    if (agent != 'apple'):
                        if (agent == 'more'):
                            print('\nJust one second...\n')
                            time.sleep(0.55)
                        else:
                            print('\nLikely invalid entry. Try again.')
                    print('\nInteraction Pairs:')
                    for counter, key in enumerate(d2):
                        print('{0}: {1}'.format(counter,key))
                        pairArray.append(key)
                    pairs = raw_input('\nEnter the numbers corresponding to interaction pairs you desire.\nInvalid entries will be ignored.\n')
                    if not pairs:
                        print('\nEnter a value.\n')
                        time.sleep(0.75)
                    pairList = np.unique(np.array([int(s) for s in pairs.split() if s.isdigit()]))
                    for pair in pairList:
                        if (pair <= counter):
                            print('\n{0}'.format(pairArray[pair]))
                            time.sleep(0.75)
                            flag = 1
                            singleMols = pairArray[pair].split("_")
                            energy1 = d.get(singleMols[0].lower())
                            energy2 = d.get(singleMols[1].lower())
                            interE = d3.get(pairArray[pair])
                            for j, step in enumerate(interE[0]):
                                bindingEnergy = Decimal('2625.5')*(step - (energy1[0] + energy2[0]))
                                print('config {0}, {1} kJ/mol\n'.format(interE[1][j].replace("/",""), bindingEnergy))
                    if (flag == 1):
                        repeat = 's'
                        while (repeat != 'y' and repeat != 'n'):
                            if (repeat != 's'):
                                print('\nInvalid entry. Try again.\n')
                            repeat = raw_input('\nAdditional data needed? (y/n)\n')
                            if not repeat:
                                print('\nEnter a value\n')
                                repeat = 's'
                            if (repeat == 'y'):
                                agent = 'more'
                            elif (repeat == 'n'):
                                agent = 'owl'
        if (switchType == 1):
            roll = 0
            while (roll != 1):
                tempControl = raw_input('\nDo you need to do additional operations? (y/n)\n')
                if (tempControl == 'y'):
                    print('\nJust one second.\n')
                    time.sleep(0.5)
                    roll = 1
                    filter = 5
                elif (tempControl == 'n'):
                    switchType = 0
                    roll = 1
                else:
                    print('\nPlease try again.\n')   
else:
    print('\nYou are logged in to the wrong place. Log in to mpi.\n')

